package com.risevision.ui.client.common.widgets.colorPicker;

/**
 * Copyright (c) 2007, AurorisNET.
 *
 * Everyone is permitted to copy and distribute verbatim copies of this license
 * document, but changing it is not allowed.
 *
 * Preamble
 *
 * This license establishes the terms under which a given free software Package
 * may be copied, modified, distributed, and/or redistributed. The intent is
 * that the Copyright Holder maintains some artistic control over the
 * development of that Package while still keeping the Package available as open
 * source and free software.
 *
 * You are always permitted to make arrangements wholly outside of this license
 * directly with the Copyright Holder of a given Package. If the terms of this
 * license do not permit the full use that you propose to make of the Package,
 * you should contact the Copyright Holder and seek a different licensing
 * arrangement.
 *
 * Definitions
 *
 * "Copyright Holder" means the individual(s) or organization(s) named in the
 * copyright notice for the entire Package.
 *
 * "Contributor" means any party that has contributed code or other material to
 * the Package, in accordance with the Copyright Holder's procedures.
 *
 * "You" and "your" means any person who would like to copy, distribute, or
 * modify the Package.
 *
 * "Package" means the collection of files distributed by the Copyright Holder,
 * and derivatives of that collection and/or of those files. A given Package may
 * consist of either the Standard Version, or a Modified Version.
 *
 * "Distribute" means providing a copy of the Package or making it accessible to
 * anyone else, or in the case of a company or organization, to others outside
 * of your company or organization.
 *
 * "Distributor Fee" means any fee that you charge for Distributing this Package
 * or providing support for this Package to another party. It does not mean
 * licensing fees.
 *
 * "Standard Version" refers to the Package if it has not been modified, or has
 * been modified only in ways explicitly requested by the Copyright Holder.
 *
 * "Modified Version" means the Package, if it has been changed, and such
 * changes were not explicitly requested by the Copyright Holder.
 *
 * "Original License" means this Artistic License as Distributed with the
 * Standard Version of the Package, in its current version or as it may be
 * modified by The Perl Foundation in the future.
 *
 * "Source" form means the source code, documentation source, and configuration
 * files for the Package.
 *
 * "Compiled" form means the compiled bytecode, object code, binary, or any
 * other form resulting from mechanical transformation or translation of the
 * Source form.
 *
 * Permission for Use and Modification Without Distribution
 *
 * (1) You are permitted to use the Standard Version and create and use Modified
 * Versions for any purpose without restriction, provided that you do not
 * Distribute the Modified Version.
 *
 * Permissions for Redistribution of the Standard Version
 *
 * (2) You may Distribute verbatim copies of the Source form of the Standard
 * Version of this Package in any medium without restriction, either gratis or
 * for a Distributor Fee, provided that you duplicate all of the original
 * copyright notices and associated disclaimers. At your discretion, such
 * verbatim copies may or may not include a Compiled form of the Package.
 *
 * (3) You may apply any bug fixes, portability changes, and other modifications
 * made available from the Copyright Holder. The resulting Package will still be
 * considered the Standard Version, and as such will be subject to the Original
 * License.
 *
 * Distribution of Modified Versions of the Package as Source
 *
 * (4) You may Distribute your Modified Version as Source (either gratis or for
 * a Distributor Fee, and with or without a Compiled form of the Modified
 * Version) provided that you clearly document how it differs from the Standard
 * Version, including, but not limited to, documenting any non-standard
 * features, executables, or modules, and provided that you do at least ONE of
 * the following:
 *
 *      (a) make the Modified Version available to the Copyright Holder of the
 *          Standard Version, under the Original License, so that the Copyright
 *          Holder may include your modifications in the Standard Version.
 *
 *      (b) ensure that installation of your Modified Version does not prevent
 *          the user installing or running the Standard Version. In addition,
 *          the Modified Version must bear a name that is different from the
 *          name of the Standard Version.
 *
 *      (c) allow anyone who receives a copy of the Modified Version to make the
 *          Source form of the Modified Version available to others under
 *
 *          (i) the Original License or
 *
 *          (ii) a license that permits the licensee to freely copy, modify and
 *              redistribute the Modified Version using the same licensing terms
 *              that apply to the copy that the licensee received, and requires
 *              that the Source form ofthe Modified Version, and of any works
 *              derived from it, be made freely available in that license fees
 *              are prohibited but Distributor Fees are allowed.
 *
 * Distribution of Compiled Forms of the Standard Version or Modified Versions
 * without the Source
 *
 * (5) You may Distribute Compiled forms of the Standard Version without the
 * Source, provided that you include complete instructions on how to get the
 * Source of the Standard Version. Such instructions must be valid at the time
 * of your distribution. If these instructions, at any time while you are
 * carrying out such distribution, become invalid, you must provide new
 * instructions on demand or cease further distribution. If you provide valid
 * instructions or cease distribution within thirty days after you become aware
 * that the instructions are invalid, then you do not forfeit any of your rights
 * under this license.
 *
 * (6) You may Distribute a Modified Version in Compiled form without the
 * Source, provided that you comply with Section 4 with respect to the Source of
 * the Modified Version.
 *
 * Aggregating or Linking the Package
 *
 * (7) You may aggregate the Package (either the Standard Version or Modified
 * Version) with other packages and Distribute the resulting aggregation
 * provided that you do not charge a licensing fee for the Package. Distributor
 * Fees are permitted, and licensing fees for other components in the
 * aggregation are permitted. The terms of this license apply to the use and
 * Distribution of the Standard or Modified Versions as included in the
 * aggregation.
 *
 * (8) You are permitted to link Modified and Standard Versions with other
 * works, to embed the Package in a larger work of your own, or to build
 * stand-alone binary or bytecode versions of applications that include the
 * Package, and Distribute the result without restriction, provided the result
 * does not expose a direct interface to the Package.
 *
 * Items That are Not Considered Part of a Modified Version
 *
 * (9) Works (including, but not limited to, modules and scripts) that merely
 * extend or make use of the Package, do not, by themselves, cause the Package
 * to be a Modified Version. In addition, such works are not considered parts of
 * the Package itself, and are not subject to the terms of this license.
 *
 * General Provisions
 *
 * (10) Any use, modification, and distribution of the Standard or Modified
 * Versions is governed by this Artistic License. By using, modifying or
 * distributing the Package, you accept this license. Do not use, modify, or
 * distribute the Package, if you do not accept this license.
 *
 * (11) If your Modified Version has been derived from a Modified Version made
 * by someone other than you, you are nevertheless required to ensure that your
 * Modified Version complies with the requirements of this license.
 *
 * (12) This license does not grant you the right to use any trademark, service
 * mark, tradename, or logo of the Copyright Holder.
 *
 * (13) This license includes the non-exclusive, worldwide, free-of-charge
 * patent license to make, have made, use, offer to sell, sell, import and
 * otherwise transfer the Package with respect to any patent claims licensable
 * by the Copyright Holder that are necessarily infringed by the Package. If you
 * institute patent litigation (including a cross-claim or counterclaim) against
 * any party alleging that the Package constitutes direct or contributory patent
 * infringement, then this Artistic License to you shall terminate on the date
 * that such litigation is filed.
 *
 * (14) Disclaimer of Warranty: THE PACKAGE IS PROVIDED BY THE COPYRIGHT HOLDER
 * AND CONTRIBUTORS "AS IS' AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES. THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR
 * NON-INFRINGEMENT ARE DISCLAIMED TO THE EXTENT PERMITTED BY YOUR LOCAL LAW.
 * UNLESS REQUIRED BY LAW, NO COPYRIGHT HOLDER OR CONTRIBUTOR WILL BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING IN ANY WAY
 * OUT OF THE USE OF THE PACKAGE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 */

import com.google.gwt.event.dom.client.ChangeEvent;
import com.google.gwt.event.dom.client.ChangeHandler;
import com.google.gwt.event.dom.client.KeyCodes;
import com.google.gwt.event.dom.client.KeyPressEvent;
import com.google.gwt.event.dom.client.KeyPressHandler;
import com.google.gwt.user.client.ui.Composite;
import com.google.gwt.user.client.ui.FlexTable;
import com.google.gwt.user.client.ui.TextBox;
import com.google.gwt.user.client.ui.Widget;

public class ColorPickerRGB extends Composite implements ColorPickerInterface, KeyPressHandler, ChangeHandler {
    // Elements
    private int red, green, blue;

    private SliderBar sliderRed, sliderGreen, sliderBlue;
    private TextBox tbRed, tbGreen, tbBlue;
    private ColorPickerPreview previewWidget = ColorPickerPreview.getInstance();

    public ColorPickerRGB() {
        red = 255;
        green = 0;
        blue = 0;

        FlexTable table = new FlexTable();

        // Add the small slider bar
        sliderRed = new SliderBar(this, false, SliderMap.Red);
        sliderGreen = new SliderBar(this, false, SliderMap.Green);
        sliderBlue = new SliderBar(this, false, SliderMap.Blue);

        // Define the Flextable's content
        tbRed = new TextBox();
        tbRed.setText(new Integer(red).toString());
        tbRed.setMaxLength(3);
        tbRed.setVisibleLength(4);
        tbRed.addKeyPressHandler(this);
        tbRed.addChangeHandler(this);
        tbGreen = new TextBox();
        tbGreen.setText(new Integer(green).toString());
        tbGreen.setMaxLength(3);
        tbGreen.setVisibleLength(4);
        tbGreen.addKeyPressHandler(this);
        tbGreen.addChangeHandler(this);
        tbBlue = new TextBox();
        tbBlue.setText(new Integer(blue).toString());
        tbBlue.setMaxLength(3);
        tbBlue.setVisibleLength(4);
        tbBlue.addKeyPressHandler(this);
        tbBlue.addChangeHandler(this);

        // Put together the FlexTable
        table.setText(0, 0, "Red:");
        table.setWidget(1, 0, sliderRed);
        table.setWidget(1, 1, tbRed);
        table.setText(2, 0, "Green:");
        table.setWidget(3, 0, sliderGreen);
        table.setWidget(3, 1, tbGreen);
        table.setText(4, 0, "Blue:");
        table.setWidget(5, 0, sliderBlue);
        table.setWidget(5, 1, tbBlue);

        styleControls();
        
        // Final setup
        initWidget(table);
    }
    
    private void styleControls() {
    	tbRed.setStyleName("rdn-TextBoxShort");
    	tbGreen.setStyleName("rdn-TextBoxShort");
    	tbBlue.setStyleName("rdn-TextBoxShort");
    }

    /**
     * This method is called when a widget is attached to the browser's document. To receive notification after a Widget has been added to the document, override the Widget.onLoad() method.
     *
     * Subclasses that override this method must call <tt>super.onAttach()</tt> before doing anything else to ensure that the Widget has been properly attached to its underlying Element.
     */
    @Override
    protected void onAttach() {
        // Called when we are shown (from being hidden)
        super.onAttach();
        updateSliders();
    }

    /**
     * Fires whenever the user generates picking events along the color picker bar.
     *
     * Subclasses that override this method must call <tt>super.onBarSelected(y)</tt> to ensure that the Widget recieves its events.
     * @param colorMode the bar which was modified
     * @param y the distance along the y-axis of the user's selection, between 0 and 255, inclusive.
     */
    public void onBarSelected(int colorMode, int y) {
        switch (colorMode)
        {
            case SliderMap.Red:
                red = y;
                tbRed.setText(Integer.toString(red));
                onChange(tbRed);
                break;
            case SliderMap.Green:
                green = y;
                tbGreen.setText(Integer.toString(green));
                onChange(tbGreen);
                break;
            case SliderMap.Blue:
                blue = y;
                tbBlue.setText(Integer.toString(blue));
                onChange(tbBlue);
                break;
        }
    }
    
    public void onMapSelected(int x, int y) {
    }

    /*
     * (non-Javadoc)
     * @see com.google.gwt.event.dom.client.ChangeHandler#onChange(com.google.gwt.event.dom.client.ChangeEvent)
     */
    public void onChange(ChangeEvent event)
    {
        onChange((Widget)event.getSource());
    }

    /**
     * Fired whenever something in this widget changes.
     *
     * Subclasses that override this method must call <tt>super.onChange(sender)</tt> to ensure that the Widget recieves its events.
     * @param sender the widget that has changed.
     */
    private void onChange(Widget sender)
    {
        if (sender == tbRed || sender == tbGreen || sender == tbBlue)
        {
            // Don't allow this value to overflow or underflow
            try
            {
                if (Integer.parseInt(((TextBox)sender).getText()) > 255)
                {
                    ((TextBox)sender).setText("255");
                }
                if (Integer.parseInt(((TextBox)sender).getText()) < 0)
                {
                    ((TextBox)sender).setText("0");
                }
            }
            catch (Exception e)
            {
            }

            red = Integer.parseInt(tbRed.getText());
            green = Integer.parseInt(tbGreen.getText());
            blue = Integer.parseInt(tbBlue.getText());

            updatePreview();
        }

        // Let the sliders know something's changed
        updateSliders();
    }
    
    private void updatePreview() {
        // Figure out colors
        try
        {
            Color color = new Color();
            color.setRGB(red, green, blue);
            previewWidget.setPreview(color.getHex());
        }
        catch (Exception e)
        {
        }
    }

    /**
     * Called whenever the internal state has been changed and needs to synchronize the other components.
     */
    private void updateSliders() {
        sliderRed.setSliderPosition(255 - red);
        sliderGreen.setSliderPosition(255 - green);
        sliderBlue.setSliderPosition(255 - blue);

    	updateSliderLayer(sliderRed, blue, green);
    	updateSliderLayer(sliderGreen, blue, red);
    	updateSliderLayer(sliderBlue, red, green);
    }
    
    private void updateSliderLayer(SliderBar sliderBar, int x, int y) {
        int horzPer = (int)((new Float(x).floatValue() / 256) * 100);
        int vertPer = (int)((new Float(y).floatValue() / 256) * 100);
        int horzPerRev = (int)(((256 - new Float(x).floatValue()) / 256) * 100);
        int vertPerRev = (int)(((256 - new Float(y).floatValue()) / 256) * 100);

        if (vertPerRev > horzPerRev)
            sliderBar.setLayerOpacity(horzPerRev, SliderBar.BarD);
        else
            sliderBar.setLayerOpacity(vertPerRev, SliderBar.BarD);
        if (vertPerRev > horzPer)
            sliderBar.setLayerOpacity(horzPer, SliderBar.BarC);
        else
            sliderBar.setLayerOpacity(vertPerRev, SliderBar.BarC);
        if (vertPer > horzPer)
            sliderBar.setLayerOpacity(horzPer, SliderBar.BarB);
        else
            sliderBar.setLayerOpacity(vertPer, SliderBar.BarB);
        if (vertPer > horzPerRev)
            sliderBar.setLayerOpacity(horzPerRev, SliderBar.BarA);
        else
            sliderBar.setLayerOpacity(vertPer, SliderBar.BarA);
    }

    /**
     * Fired when a keyboard action generates a character. This occurs after onKeyDown and onKeyUp are fired for the physical key that was pressed.
     *
     * It should be noted that many browsers do not generate keypress events for non-printing keyCode values, such as KEY_ENTER or arrow keys. These keyCodes can be reliably captured either with onKeyDown(Widget, char, int) or onKeyUp(Widget, char, int).
     *
     * Subclasses that override this method must call <tt>super.onKeyPress(sender, keyCode, modifiers)</tt> to ensure that the Widget recieves its events.
     * @param sender the widget that was focused when the event occurred.
     * @see com.google.gwt.user.client.ui.KeyboardListener
     */
    public void onKeyPress(KeyPressEvent event) {
        Widget sender = (Widget) event.getSource();
        char keyCode = event.getCharCode();

        // Disallow non-numerics in numeric boxes
        if ((!Character.isDigit(keyCode))
            && (keyCode != (char) KeyCodes.KEY_TAB)
            && (keyCode != (char) KeyCodes.KEY_BACKSPACE)
            && (keyCode != (char) KeyCodes.KEY_DELETE) && (keyCode != (char) KeyCodes.KEY_ENTER)
            && (keyCode != (char) KeyCodes.KEY_HOME) && (keyCode != (char) KeyCodes.KEY_END)
            && (keyCode != (char) KeyCodes.KEY_LEFT) && (keyCode != (char) KeyCodes.KEY_UP)
            && (keyCode != (char) KeyCodes.KEY_RIGHT) && (keyCode != (char) KeyCodes.KEY_DOWN))
        {
            ((TextBox)sender).cancelKey();
        }
    }

    public void setColor(Color color) {
        this.red = color.getRed();
        this.green = color.getGreen();
        this.blue = color.getBlue();

        tbRed.setText(Integer.toString(this.red));
        tbGreen.setText(Integer.toString(this.green));
        tbBlue.setText(Integer.toString(this.blue));

        updateSliders();
    }

}